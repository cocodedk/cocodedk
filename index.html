<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cocode.dk</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #0d0d0d;
      font-family: sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      z-index: 2;
      position: relative;
    }
    #tooltip {
      position: absolute;
      background: #222;
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
    #infoBox {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 420px;
      max-width: 95%;
      background: #1a1a1a;
      color: #0f0;
      border: 1px solid #444;
      border-radius: 10px;
      padding: 15px;
      font-size: 14px;
      display: none;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      z-index: 100;
      font-family: 'Courier New', Courier, monospace;
      line-height: 1.5;
      white-space: normal;
      transition: all 0.2s ease;
      transition: z-index 0.3s ease;
    }
    #debug {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #fff;
      font-size: 12px;
      font-family: monospace;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      border-radius: 3px;
      max-width: 500px;
      z-index: 1000;
    }
    .new-entry {
      color: #00ff00;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .entry-separator {
      border-top: 1px solid #444;
      margin: 12px 0;
      opacity: 0.6;
    }
    .old-entry {
      color: #88ff88;
      opacity: 0.7;
    }
    .busy {
      border-color: #ff4444 !important;
      box-shadow: 0 0 10px rgba(255, 68, 68, 0.3);
    }
    .canvas-overlap {
      z-index: 1;
    }
    #infoBox.canvas-overlap {
      z-index: 1;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    #infoBox:not(.canvas-overlap) {
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="graph"></canvas>
  <div id="tooltip"></div>
  <div id="infoBox"></div>
  <div id="debug"></div>
  <script>
    // Debug element
    const debug = document.getElementById('debug');

    // Initialize canvas and context
    const canvas = document.getElementById('graph');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const infoBox = document.getElementById('infoBox');

    // Node colors and styles
    const colors = {
        default: {
          fill: '#333',
          stroke: '#aaa',
          text: '#fff'
        },
        hover: {
          fill: '#4a4a4a',
          stroke: '#ddd',
          text: '#fff'
        },
        categories: {
          'cocode.dk': { fill: '#005577', stroke: '#00ccff', text: '#ffffff' },
          'Software': { fill: '#0077cc', stroke: '#33ccff', text: '#ffffff' },
          'Cybersecurity': { fill: '#cc0044', stroke: '#ff6688', text: '#ffffff' },
          'Clients': { fill: '#cc8800', stroke: '#ffcc33', text: '#000000' },
          'Contact': { fill: '#8800cc', stroke: '#cc66ff', text: '#ffffff' }
        }
      };

    // Define nodes with updated structure
    const nodes = [
        { id: 'cocode.dk', x: 0, y: 0, r: 50, info: 'cocode.dk is a freelance IT consultancy based in Denmark specializing in custom software development, graph databases, and cybersecurity services including compliance and audit automation.', category: 'cocode.dk' },

        { id: 'Software', x: 0, y: -150, r: 40, info: 'Full-stack custom software solutions built with modern frameworks such as Django and React. Scalable, maintainable systems designed for business efficiency.', category: 'Software' },
        { id: 'Cybersecurity', x: 0, y: 150, r: 40, info: 'Cybersecurity consulting including gap assessments, pentest coordination, risk remediation, and framework compliance (CIS18, NIST, ISO).', category: 'Cybersecurity' },
        { id: 'Clients', x: 150, y: 0, r: 40, info: 'Real-world freelance IT and security projects delivered across Europe. Includes Django apps, CMDB reviews, and automated compliance tools.', category: 'Clients' },
        { id: 'Contact', x: -150, y: 0, r: 40, info: 'Reach out to cocode.dk for IT consultancy or cybersecurity projects. Email: info@cocode.dk — based in Denmark, fluent in English, Danish, and Persian.', category: 'Contact' },

        { id: 'Python', x: -100, y: -200, r: 30, info: 'Backend automation, API development, scripting, and data processing using Python — the core language for robust digital infrastructure.', category: 'Software' },
        { id: 'Django', x: 0, y: -250, r: 30, info: 'Development of secure, scalable web applications using Django. Includes admin systems, APIs, authentication and integrations.', category: 'Software' },
        { id: 'Neo4j', x: 100, y: -200, r: 30, info: 'Graph database expertise for mapping infrastructure, assets, systems, and relationships. Used for CMDB modeling and control tracking.', category: 'Software' },
        { id: 'AI Integrations', x: -70, y: -300, r: 30, info: 'Implementation of AI features like LLMs (GPT, Claude, Mistral) in workflows, from risk evaluations to automated audits and insight generation.', category: 'Software' },
        { id: 'AI Wrappers', x: 70, y: -300, r: 30, info: 'Custom logic layers around large language models for task-specific automation, data enhancement, and secure contextual use.', category: 'Software' },

        { id: 'Compliance', x: -100, y: 200, r: 30, info: 'Specialized in CIS18, DORA, NIS2, ISO27000 compliance through graph-based audit mapping, evidence collection, and scope tracking.', category: 'Cybersecurity' },
        { id: 'Audit', x: 100, y: 200, r: 30, info: 'Design and execution of cybersecurity gap assessments, audits, control mappings, and remediation project documentation.', category: 'Cybersecurity' },

        { id: 'Podcast', x: -100, y: -50, r: 30, info: 'Psychology podcast in Persian language focused on Jungian concepts such as archetypes, individuation, and culture through a depth psychology lens.', category: 'Contact' },
        { id: 'Vibe Coding', x: 150, y: -120, r: 30, info: 'Creative coding and interface design with expressive elements, custom interactions, and unique structural logic that reflects thinking patterns.', category: 'Software' },
    ];

    console.log('Nodes defined:', nodes.length);

    // Define links between nodes
    const links = [
      // Main branches from center
      ['cocode.dk', 'Software'],
      ['cocode.dk', 'Cybersecurity'],
      ['cocode.dk', 'Clients'],
      ['cocode.dk', 'Contact'],

      // Software connections
      ['Software', 'Python'],
      ['Software', 'Django'],
      ['Software', 'Neo4j'],
      ['Software', 'AI Integrations'],
      ['Software', 'AI Wrappers'],
      ['Software', 'Vibe Coding'],

      // Cybersecurity connections
      ['Cybersecurity', 'Compliance'],
      ['Cybersecurity', 'Audit'],

      // Other connections
      ['Contact', 'Podcast']
    ];

    console.log('Links defined:', links.length);

    // Track hover state
    let hoveredNode = null;

    // Add at the top of the script
    let animationState = {
      active: false,
      currentInterval: null,
      queue: []
    };

    // Helper function to resize canvas and maintain centering
    function resizeCanvas() {
      console.log('Resizing canvas to window size:', window.innerWidth, 'x', window.innerHeight);
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      debug.textContent = `Canvas size: ${canvas.width} x ${canvas.height}`;
      centerGraph();
      drawGraph();
    }

    // Function to calculate text width and adjust node radius if needed
    function calculateNodeRadius(node) {
      ctx.font = '12px sans-serif';
      const textWidth = ctx.measureText(node.id).width;
      // Ensure radius is at least wide enough to contain text plus padding
      return Math.max(node.r, (textWidth / 2) + 10);
    }

    // Function to center the graph in the canvas
    function centerGraph() {
      console.log('Centering graph');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      nodes.forEach(node => {
        // Store original position as offsets from center
        if (!node.hasOwnProperty('offsetX')) {
          node.offsetX = node.x;
          node.offsetY = node.y;
        }

        // Update position based on canvas center
        node.x = centerX + node.offsetX;
        node.y = centerY + node.offsetY;

        // Ensure radius is appropriate for text
        node.r = calculateNodeRadius(node);
      });

      // Log the position of the central node
      const centralNode = nodes.find(n => n.id === 'cocode.dk');
      if (centralNode) {
        console.log('Central node position:', centralNode.x, centralNode.y);
        debug.textContent += `\nCenter node: ${centralNode.x.toFixed(0)},${centralNode.y.toFixed(0)}`;
      }
    }

    // Function to draw a node
    function drawNode(node) {
      // Determine if this is the hovered node
      const isHovered = (node === hoveredNode);

      // Get appropriate colors
      let fillColor, strokeColor, textColor;

      if (isHovered) {
        fillColor = colors.hover.fill;
        strokeColor = colors.hover.stroke;
        textColor = colors.hover.text;
      } else if (colors.categories[node.category]) {
        fillColor = colors.categories[node.category].fill;
        strokeColor = colors.categories[node.category].stroke;
        textColor = colors.default.text;
      } else {
        fillColor = colors.default.fill;
        strokeColor = colors.default.stroke;
        textColor = colors.default.text;
      }

      // Draw node circle
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = isHovered ? 2 : 1;
      ctx.stroke();

      // Draw node text (revert to white)
      ctx.fillStyle = '#ffffff'; // Force white text
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.id, node.x, node.y);
    }

    // Function to draw a link between nodes
    function drawLink(from, to) {
      if (!from || !to) {
        console.error('Missing node in link', from, to);
        return;
      }

      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Function to draw the entire graph
    function drawGraph() {
      console.log('Drawing graph');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw links first (so they appear behind nodes)
      links.forEach(link => {
        const from = nodes.find(n => n.id === link[0]);
        const to = nodes.find(n => n.id === link[1]);

        if (!from || !to) {
          console.error('Could not find nodes for link:', link);
          return;
        }

        drawLink(from, to);
      });

      // Draw nodes on top
      nodes.forEach(drawNode);

      console.log('Graph drawn');
    }

    // Function to find a node under the mouse cursor
    function getMouseNode(mx, my) {
      return nodes.find(node => {
        const dx = mx - node.x;
        const dy = my - node.y;
        return dx * dx + dy * dy < node.r * node.r;
      });
    }

    // Modified applyTextEffect
    function applyTextEffect(newText, element) {
      // Queue system
      if (animationState.active) {
        animationState.queue.push(newText);
        element.style.cursor = 'progress';
        return;
      }

      animationState.active = true;
      const entryContainer = document.createElement('div');
      const header = document.createElement('div');
      header.className = 'new-entry';

      element.prepend(entryContainer);
      entryContainer.appendChild(header);

      let index = 0;
      animationState.currentInterval = setInterval(() => {
        if (index < newText.length) {
          header.textContent = newText.substring(0, index) +
                            String.fromCharCode(33 + Math.floor(Math.random() * 94));
          index++;
        } else {
          clearInterval(animationState.currentInterval);
          header.textContent = newText;
          // Add separator
          const separator = document.createElement('div');
          separator.className = 'entry-separator';
          entryContainer.appendChild(separator);

          // Process queue
          animationState.active = false;
          if (animationState.queue.length > 0) {
            applyTextEffect(animationState.queue.shift(), element);
          }
          element.style.cursor = 'default';

          // Mark previous entries
          Array.from(element.querySelectorAll('.new-entry')).forEach(el => {
            if (el !== header) el.classList.add('old-entry');
          });
        }
      }, 10);
    }

    // Mouse move event handler
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Find node under cursor
      const nodeUnderCursor = getMouseNode(mx, my);

      // Handle hover effects
      if (nodeUnderCursor) {
        // Update tooltip
        tooltip.style.left = `${e.clientX + 10}px`;
        tooltip.style.top = `${e.clientY + 10}px`;
        tooltip.textContent = nodeUnderCursor.id;
        tooltip.style.opacity = 1;

        // Set hover state
        if (hoveredNode !== nodeUnderCursor) {
          hoveredNode = nodeUnderCursor;
          drawGraph(); // Redraw with hover effect
        }
      } else {
        // Reset hover state
        tooltip.style.opacity = 0;
        if (hoveredNode !== null) {
          hoveredNode = null;
          drawGraph(); // Redraw without hover effect
        }
      }
    });

    // Click event handler
    canvas.addEventListener('click', (e) => {
      if (animationState.active) {
        infoBox.classList.add('busy');
        setTimeout(() => infoBox.classList.remove('busy'), 200);
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const clicked = getMouseNode(mx, my);
      if (clicked) {
        infoBox.style.display = 'block';
        applyTextEffect(clicked.info, infoBox);
        debug.textContent += `\nClicked: ${clicked.id}`;
      } else {
        infoBox.style.display = 'none';
      }
    });

    // Window resize handler
    window.addEventListener('resize', resizeCanvas);

    // Initial rendering
    console.log('Starting initial rendering');
    resizeCanvas();

    // Force a redraw after a short delay to ensure canvas is properly sized
    setTimeout(() => {
      console.log('Forced redraw after timeout');
      resizeCanvas();
    }, 100);

    // Add after node definitions
    function checkInfoBoxOverlap() {
      const infoBoxRect = infoBox.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();

      // Check overlap with any node
      const overlap = nodes.some(node => {
        const nodeX = canvasRect.left + node.x - (node.r * 2);
        const nodeY = canvasRect.top + node.y;
        const nodeRight = nodeX + node.r;
        const nodeBottom = nodeY + node.r;

        return (
          nodeX < infoBoxRect.right &&
          nodeRight > infoBoxRect.left &&
          nodeY < infoBoxRect.bottom &&
          nodeBottom > infoBoxRect.top
        );
      });

      infoBox.classList.toggle('canvas-overlap', overlap);
      return overlap;
    }

    function checkInfoBoxHeight() {
      const infoBoxRect = infoBox.getBoundingClientRect();
      const viewportHeight = window.innerHeight;

      // Check if bottom edge is within 50px of screen bottom
      if (infoBoxRect.bottom > viewportHeight - 50) {
        // Remove oldest entry (last child element)
        if (infoBox.children.length > 1) {
          infoBox.removeChild(infoBox.lastElementChild);
        }
      }
    }

    // Create ResizeObserver for infoBox
    const resizeObserver = new ResizeObserver(entries => {
      checkInfoBoxHeight(); // New height check
      if (checkInfoBoxOverlap()) {
        infoBox.classList.add('canvas-overlap');
      } else {
        infoBox.classList.remove('canvas-overlap');
      }
    });

    resizeObserver.observe(infoBox);

    // Add initial check
    setTimeout(() => checkInfoBoxOverlap(), 100);
  </script>
</body>
</html>
